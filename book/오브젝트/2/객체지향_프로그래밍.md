### 객체지향 프로그래밍을 하려고 할 때, 시작점은 어떻게 되어야 하는가?

1. 어떤 클래스가 필요한지가가 아니라 어떤 객체가 필요한지 고민하자.
  - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
2. 객체를 기능을 구현하기 위해 협력하는 공동체의 일원으로 보자.
3. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하자.

---

### 도메인이란?
영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것. 이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.(= 어떤 시스템의 목적을 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.)

### 도메인의 구조를 따르는 프로그램 구조
객체지향 패러다임의 강력한 점은 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다는 점이다.  
일반적으로 클래스의 이름은 대응되는 도메인 개념의 이른과 동일하거나 유사하게 지어햐 하고, 클래스 사이의 관계 또한 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.

---

### 클래스 구현하기
* 자율적인 객체
  - 인터페이스과 구현의 분리 (이를 통해 외부의 간섭을 최소화 하고, 객체 스스로 요청을 해결하도록 한다.)
    - 인터페이스: public으로 제공될 주요 메서드. (여기에서 인터페이스는 대상을 사용하는 것과 관련된 의미의 인터페이스이다.)
    - 구현: private, protected메서드나 속성.
* 프로그래머의 자유  
  - 프로그래머의 역할은 클래스 작성자(class creator), 클라이언트 프로그래머(client programmer) 두 가지로 구분하면 유용하다.  
    - 클래스 작성자: 새로운 데이터 타입을 프로그램에 추가하는 역할.  
    - 클라이언트 프로그래머: 클래스 작성자가 추가한 데이터 타입을 사용하는 역할.

클래스 작성자는 클라이언트 프로그래머가 필요한 부분만 공개하고, 내부 구현은 숨겨놓음으로써 필요할 때 내부 구현을 마음껏 바꿀 수 있다. 이를 **구현 은닉**이라고 한다. 이것은 변경을 관리하는데 큰 도움을 준다.

---

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

상속을 이용하면 컴파일 시간에는 추상 클래스에 의존하고, 실행 시간에는 구현 클래스에 의존하게 된다. 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 다를 수 있고 다르다면 확장성이 높아진다.  

반면 다르면 다를수록, 코드를 이해하기 어려워진다. 이는 의존성의 양면이며, 설계가 트레이드 오프의 산물이라는 사실을 보여준다.

해당 클래스의 코드만으로는 어떤 객체에 의존하는지 알 수 없고, 해당 클래스의 인스턴스를 생성하는 부분을 봐야 알 수 있다.

설계가 유연할 수록, 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 반면 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만, 재사용성과 확장 가능성은 낮아진다.

> **좋은 객체지향 설계를 하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.**

---

### 차이에 의한 프로그래밍

클래스를 하나 만들고 싶은데, 그 클래스가 기존의 어떤 클래스와 매우 비슷하다고 가정하자. 그 클래스의 코드를 가져와 조금만 수정하거나 그대로 쓰면 좋겠다. 이를 가능하게 해주는게 상속이다.

상속을 이용하면, 클래스 사이에 관계를 설정하는 것만으로도 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다. 또 오버라이딩을 통해 행동을 수정할 수도 있다.

이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍**이라고 부른다.

---

### 상속과 인터페이스

상속에 대한 인식을 한 번 다시 보자. 일반적으로 상속의 목적은 메서드나 인스턴스 변수를 재사용하는 것이라 생각한다.  
상속의 인식을 인터페이스 관점으로 바꾸자. (자식 클래스의 인터페이스 = 자신의 인터페이스 + 부모 클래스의 인터페이스)

---

### 다형성

다형성은 동일한 메시지를 받았을 때, 객체의 타입에 따라 다르게 응답하는 능력을 의미한다.  
이는 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있기 때문에 가능하고, 이는 바인딩과 관련이 있다.(지연 바인딩을 메커니즘을 이용)

지연 바인딩, 동적 바인딩: 메시지와 메서드를 실행 시점에 바인딩.
초기 바인딩, 정적 바인딩: 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것.

다형성은 상속만이 아니라 실체화를 통해서도 가능하다.

* 구현 상속과 인터페이스 상속  
  - 구현 상속: 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용.
  - 인터페이스 상속: 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것.

상속은 구현 인터페이스 상속을 위해 사용해야 한다. 그렇지 않으면 변경에 취약한 코드를 낳게 될 확률이 높다.

---

## 추상화와 유연성

### 추상화의 힘
1. 요구사항의 정책을 높은 수준에서 서술할 수 있다.(세부사항을 서술하지 않아도 됨)
2. 설계가 유연해진다.(기존 구조를 수정하지 않아도 됨)

### 유연한 설계
`null`을 통한 예외 케이스 취급이 아닌 `NoneDiscountPolicy`을 구현하여 사용하는 이야기.
> **유연성이 필요한 곳에 추상화를 사용하라**

### 추상 클래스와 인터페이스 트레이드오프
`DiscountPolicy`를 인터페이스로 정의하고 `NoneDiscountPolicy`와, `DefaultDiscountPolicy`를 실체화해서 사용하는 이야기.
> **작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다. 고민하고 트레이드오프하라.**

---

### 코드 재사용
코드 재사용을 위해서는 상속보다 **합성**이 더 좋은 방법이다.(다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법)  
상속은 합성으로 상호교환 가능하다. 그런데 합성이 더 좋은 이유는 뭘까?

### 상속
1. 상속은 캡슐화를 위반한다.
2. 설계를 유연하지 못하게 만든다.

상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알아야 한다. 결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화되고, 두 클래스의 결합이 강해지므로, 부모 클래스를 변경할 때, 자식 클래스도 함께 변경될 확률이 올라간다.

상속은 부모, 자식 클래스의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 바꾸는 것은 불가능하다. 하지만 합성일 경우, 간단하게 교체해주면 끝난다.

### 합성
합성은 상속의 두 가지 문제를 모두 해결한다.

1. 인터페이스에 정의된 메시지를 통해서 재사용을 하므로 캡슐화를 위반하지 않는다.(인터페이스만 알면 됨. 내부구현을 알 필요가 없음)
2. 인스턴스를 교체만 하면 되므로 설계가 비교적 유연하다.

따라서 코드 재사용을 위해서는 합성 > 상속 이다.

> **대부분의 설계에서는 상속과 합성을 함께 사용해야 한다. 코드를 재사용하는 경우에는 상속보다 합성이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다.**

---

### 정리

1. 어느 기능을 구현해야 하는 경우. 맨 처음 해야할 일은 도메인을 설계하는 일이다.
2. 도메인을 설계할 때는, 어떤 객체들이 필요한지를 우선적으로 고민하고 상태와 행동을 주도록 한다. 객체들은 협력을 통해 역할을 수행한다.
3. 공통적인 상태와 행동들이 발견된다면 같은 타입으로 분류할 수 있고, 이는 상속과 합성을 이용하여 구현될 수 있다.
4. 상속과 합성은 각자의 장점이 있으며 함께 사용될 수 밖에 없고, 이는 트레이드오프이다.
5. 작은 결정이더라도 트레이드오프를 통해 결론을 얻도록 한다.
