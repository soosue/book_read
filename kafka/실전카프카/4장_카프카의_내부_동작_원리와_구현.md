# 4 카프카의 내부 동작 원리와 구현

## 4.1 카프카 리플리케이션

### 4.1.1 리플리케이션 동작 개요

프로듀서에서 토픽으로 메시지를 보내면 카프카 클러스터를 이루고 있는 다른 브로커들도 동일한 메시지를 가지고 있는다.

중요한 점은 토픽이 복사되는 것이 아니라 토픽을 구성하는 각각의 파티션들이 리플리케이션 된다.

### 4.1.2 리더와 팔로워

카프카의 리플리케이션에는 리더와 팔로워의 개념이 있다.

리더와 팔로워는 각자의 역할을 분담한다.

리더는 리플리케이션 중 하나가 선정되며, 모든 읽기와 쓰기는 해당 리더를 통해서만 가능하다.

즉, 프로듀서는 리더에게만 메시지를 전송하고, 컨슈머도 리더에게서만 메시지를 가져온다.

팔로워는 리더에 문제가 있을 경우를 대비해 리더가 될 준비를 한다.

컨슈머가 토픽의 메시지를 가져가는 것과 비슷하게 지속적으로 파티션의 리더가 새로운 메시지를 받았는지 확인하고, 있다면 해당 메시지를 리더로부터 복제한다.

### 4.1.3 복제 유지와 커밋

리더와 팔로워 간에 복제 동작은 어떻게 이루어질까?

리플리케이션은 ISR(InSyncReplica) 단위로 이루어진다.

리더와 팔로워는 ISR 라는 논리적 그룹으로 묶여있는데, 이 그룹은 새로운 리더가 될 자격이 있는 그룹이다.

ISR 내의 팔로워들은 지속적으로 리더의 데이터를 따라가고, 리더는 팔로워들이 잘 따라오고 있는지 확인한다.

따라가지 못한다면 해당 팔로워는 새로운 리더가 될 자격이 없다고 말할 수 있다.

다시 말해, 팔로워들은 지속적으로 리더의 데이터를 리플리케이션 하고

리더는 읽기, 쓰기 외에도 팔로워가 리플리케이션 동작을 잘 하고 있는지 확인한다.

특정 주기 시간만큼 복제 요청을 하지 않는다면 해당 팔로워가 문제 있다고 판단하고 ISR 그룹에서 추방한다.

ISR 내에서 모든 팔로워의 복제가 완료되면 리더는 내부적으로 커밋을 한다. 마지막 커밋 오프셋 위치를 하이워터마크라고 부른다.

커밋은 어디까지 팔로워들이 복제했는지를 표시하면, 리플리케이션 팩터 수의 모든 리플리케이션이 전부 메시지를 저장했음을 의미한다.

그리고 컨슈머들은 메시지의 일관성을 위해 커밋된 메시지만 읽어갈 수 있다.

참고)

ISR은 토픽 상세보기를 통해 육안으로 확인할 수 있다.

하이워터마크는 로그 디렉터리에서 볼 수 있으며 /data/kafka-logs/replication-offset-checkpoint 파일에서 확인할 수 있다.(모든 브로커가 같은 결과를 가진다)

특정 토픽, 파티션에 복제가 되지 않거나 문제가 있다고 판단되는 경우, replication-offset-checkpoint 파일을 다른 리플리케이션 되는 브로커와 비교하면, 어떤 브로커, 토픽, 파티션에 문제가 있는지 파악할 수 있다.

### 4.1.4 리더와 팔로워의 단계별 리플리케이션 동작

카프카에서 리더는 매우 바쁘게 동작하기에 부하를 줄이기 위한 여러가지 방법이 동원된다.

그 중 하나는 리플리케이션 동작을 처리할 때 서로 통신을 최소화하도록 ACK 통신을 제거한 것이다.

래빗MQ의 트랜잭션 모드에서는 모든 미러(mirror)가 메시지를 받았는지에 대한 ACK을 리턴하므로 리더는 미러들이 메시지를 받았는지 알 수 있다.

하지만 카프카에서는 팔로워들이 리플리케이션 동작을 수행하면, 리더는 팔로워들이 리플리케이션 요청을 보냈다는 사실은 알지만, 리플리케이션에 성공했는지 여부는 알지 못한다.(ACK을 제거했으므로)

카프카는 팔로워의 다음 리플리케이션 요청을 보고 메시지를 잘 읽어갔는지 확인한다.

0번 오프셋 메시지에 대한 리플리케이션이 성공했다면, 팔로워들은 다음 요청에서는 1번 오프셋 메시지에 대한 리플리케이션 요청을 보낼 것이다.

리더 입장에서는 1번 오프셋 메시지 요청이 오면, 0번 오프셋 메시지 리플리케이션은 성공했음을 인지하고 0번 오프셋 메시지에 대해 커밋을 표시한 후, 하이워터마크를 증가시킨다.

이후 리플리케이션 요청에 대해서 0번 오프셋 메시지가 커밋되었다는 내용도 함께 전달한다.

그러면 팔로워들은 0번 오프셋 메시지가 커밋되었다는 사실을 인지하고 리더와 동일하게 커밋을 표시한다.

카프카는 이렇게 ACK을 제거하면서도 리플리케이션을 안정적으로 동작하게 만들었다.

또 리플리케이션 동작 방식이 리더가 푸시하는 방식이 아닌 팔로워가 풀하는 방식으로 동작하는 것도, 리플리케이션 동작에서 리더의 부하를 줄여주기 위해서다.

### 4.1.5 리더에포크와 복구

리더에포크란 카프카의 파티션들이 복구 동작을 할 때 메시지의 일관성을 유지하기 위해 필요한 정보이다.

컨트롤러에 의해 관리되며, 숫자로 표현된다.

현재 리더에포크 번호, 리더에포크 번호, 최종 커밋 후 새로운 메시지를 전송받게 될 오프셋 번호로 이루어진다.

리더에포크가 있다고 메시지 손실이 아예 안 일어나는 것은 아니니 주의하자.

정보는 /data/kafka-logs/토픽-파티션번호/leader-epoch-checkpoint 파일에서 확인할 수 있다.

## 4.2 컨트롤러

카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하며, 리더 선출을 맡는다. 파티션의 ISR 리스트 중에서 리더를 선출하며 ISR 리스트는 주키퍼에 저장되어 있다.

컨트롤러는 브로커가 실패하는 것을 예의주시하며, 실패가 감지되면 즉시 ISR 리스트 중 하나를 새로운 파티션 리더로 선출한다. 그러고 나서 새로운 리더의 정보를 주키퍼에 기록하고, 변경된 정보를 모든 브로커에게 전달한다.

리더가 다운되면, 클라이언트들은 재시도 숫자만큼 재시도를 한다. 이 사이에 빠른 리더 선출이 이루어져야 한다.

불필요한 로깅과 주키퍼 비동기 API로 리더 선출 작업 속도는 훨씬 빨라졌다.

제어된 종료도 리더 선출 작업을 가진다.

급작스러운 종료와 제어된 종료의 차이는 다운 타임이 있고, 제어된 종료는 브로커가 모든 로그를 디스크에 동기화 한 후 종료되므로, 브로커 재시작시 로그 복구시간이 짧다.

제어된 종료를 사용하기 위해선 브로커 설정 파일인 server.properties에 controlled.shutdown.enable = true로 설정되어야 한다.

확인은 /usr/local/kafka/bin/kafka-configs.sh --bootstrap-server 서버정보 --broker 1 --describe --all로 할 수 있다.

## 4.3 로그(로그 세그먼트)

### 4.3.1 로그 세그먼트 삭제

### 4.3.2 로그 세그먼트 컴팩션

## 4.4 정리
