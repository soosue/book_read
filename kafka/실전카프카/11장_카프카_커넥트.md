# 11. 카프카 커넥트

데이터베이스, 파일, 카프카 클러스터 등 외부 시스템과 카프카 클러스터를 손쉽게 연결하기 위한 프레임워크이다.

직접 프로듀서와 컨슈머를 개발해서 원하는 동작을 수행할 수도 있지만, 개발하고 운영하는데 들어가는 비용이 크다고 생각된다면 카프카 커넥트를 이용해보는 것도 좋다.

REST API를 이용해 설정을 조정할 수도 있으며, 많은 오픈 소스도 준비되어 있다.

장점

- 카프카로 데이터를 보내거나 카프카에서 데이터를 가져오기 때문에, 데이터 중심의 파이프 라인이 구성된다.
- 테스트 용도의 단일모드, 운영 환경을 위한 분산모드로 실행할 수 있으므로, 유연하고 확장성이 있다.
- 기존 만들어진 커넥터들을 재활용할 수 있고, 쉽게 수정할 수 있으므로, 기능 확장을 위한 운영 오버헤드가 낮다
- 분산모드가 존재하기 때문에, 고가용성이 보장된다.

## 11.1 카프카 커넥트의 핵심 개념

`소스` -> `소스 커넥트` -> `카프카 클러스터` -> `싱크 커넥트` -> `싱크`

소스 커넥트, 싱크 커넥트로 구분되며

이렇게 프로듀서, 컨슈머 느낌으로 카프카 클러스터 양쪽에 위치하고 있다.


카프카 커넥트의 상세 구성도를 보면, 카프카 커넥트는 워커, 커넥터, 태스크로 구성된다.

단일모드라면 워커는 1대이고, 분산모드라면 워커(서버 인스턴스)는 여러 대로 구성할 수 있다.

워커는 카프카 커넥트가 실행되는 서버를 의미하고 커넥터, 태스크들이 실행된다. (소스 커넥트, 싱크 커넥트)

커넥터는 직접 데이터를 복사하는 것이 아닌, 어디에서 어디로 복사해야하는지 작업을 정의하고 관리하는 역할을 한다. (소스 커넥터, 싱크 커넥터)

태스크는 커넥터가 정의한 작업을 직접 수행하는 역할을 한다. (소스 태스크, 싱크 태스크)

## 11.2 카프카 커넥트의 내부 동작

태스크들이 데이터를 소스에커 카프카 혹은 카프카에서 싱크로 이동시킬 때,

커넥트는 병렬처리를 위해 파티셔닝 개념을 적용해 데이터들을 하위 집합으로 나눈다.

태스크 수에 맞게 파티션이 할당되고, 태스크들은 동작을 처리한다.

커넥트의 파티션에도 오프셋이 있어서 장애시 장애지점부터 다시 데이터를 이동시킬 수 있다.
