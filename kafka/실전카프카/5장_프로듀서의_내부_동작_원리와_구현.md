# 5.프로듀서의 내부 동작 원리와 구현

* 프로듀서의 기본 역할

프로듀서 ====== send(메시지) =====> 카프카

```
send() {
  1. 시리얼라이저
  2. 파티셔너
}
```

## 5.1 파티셔너

파티셔너: 카프카 토픽의 어떤 파티션으로 메시지를 보낼지 결정. (기본적으로는 메시지의 키값을 이용해서 결정한다.)

*주의: 키값으로 파티션 결정시 파티션 수 증가시 다른 파티션에 메시지가 인입될 수 있으므로, 파티션 수는 변경하지 않는 것을 권장한다.

### 5.1.1 라운드 로빈 전략

메시지 키값이 null인 경우 라운드 로빈 전략이 선택된다.

파티셔너를 통해 어떤 파티션에 보내질지 결정된 메시지들은 버퍼 메모리 영역에서 잠시 대기한다.

이 때, 라운드 로빈일 경우 발생하는 비효율적인 모습이 있다.

1. 배치 전송을 위한 최소 레코드 수를 넘지 못하면 전송되지 않는다.
2. 시간 옵션을 조정하면 1번은 해결되지만, 배치와 압축의 효과를 얻지 못한채 메시지 하나만 전송되는 경우가 생긴다.

스티키 파티셔닝 전략이 보완한다.

### 5.1.2 스티키 파티셔닝 전략

카프카 2.4버전(2019)부터 사용하게 한 전략이다.

하나의 파티션에 레코드를 먼저 채우는 배치 전송 전략이다.

기본 설정에 비해 약 30%이상 지연 시간이 감소하고, 프로듀서의 CPU 사용율도 줄어들었다.

`???`카프카로 전송하는 메시지의 순서가 중요하지 않은 경우에 적용하기를 권장한다.

## 5.2 프로듀서의 배치

메시지를 한 개씩 전송하는 것이 아닌, 여러 개 모아서 전송한다.

프로듀서에서 처리량을 높이기 위해 배치 전송을 권장한다.

프로듀서의 버퍼 메모리에 영역에 토픽의 파티션 별로 메시지를 담아 놓는다.

- buffer.memory: 32MB, 메시지를 담아 놓는 버퍼 메모리의 용량이다.
- batch.size: 16KB, 배치 전송을 위해 메시지를 묶는 단위이다.
- linger.ms: 0ms, 버퍼 메모리에 메시지들이 대기하는 최대 시간이다.

배치 전송 장점
- 불필요한 I/O를 줄일 수 있다.(전송 요청 수 감소)

배치 전송 단점
- 배치 사이즈를 늘리면, 지연시간이 늘어난다.

*주의: buffer.memory > 토픽들의 파티션 수 * batch.size + 재시도 수행 메모리

## 5.3 중복 없는 전송

카프카는 중복 없는 전송을 제공한다. (멱등성을 가진다. - 프로듀서를 이용해 수차례 중복 전송을 하더라도 카프카에는 중복 없이 한 번만 저장된다.)

- 적어도 한 번 전송
- 최대 한 번 전송
- 정확히 한 번 전송

카프카에서는 PID(Producer ID)와 시퀀스 번호(메시지 번호)를 이용해 중복 없는 전송을 구현했다.

프로듀서에서 PID와 시퀀스 번호를 메시지 헤더에 포함하여 전송하면, 브로커는 각 메시지마다 PID값과 시퀀스 번호를 메모리에 유지하고, 이를 이용해 중복 여부를 알 수 있다.

분명히 성능은 떨어진다.(20% 정도) 하지만, 큰 영향은 아니므로, 프로듀서의 전송 성능에 민감하지 않다면 사용할 것을 권장한다.

옵션 설정

- enable.idempotence: false, 프로듀서가 중복 없는 전송을 해야할 때 true로 설정. 밑의 옵션들도 설정 해야한다. or ConfigException 발생한다.
- max.in.flight.requests.per.connection: 5, ACK를 받지 않는 상태에서 하나의 커넥션에서 보낼 수 있는 최대 요청 수. 5 이하로 설정.
- acks: 1, 중복 없는 전송시 all로 설정.
- retries: 5, ACK를 받지 못한 경우 재시도 해야하므로 0보다 큰 값으로 설정해야 한다.

별도의 설정파일에 위 옵션을 기재하고, `/usr/local/kafka/bin/kafka-console.producer.sh`의 `--producer.config`옵션으로 파일을 등록한다.

`/data/kafka-logs/토픽-파티션번호` 위치에서 `.snapshot`파일에서 PID와 시퀀스번호를 확인할 수 있다.


## 5.4 정확히 한 번 전송

정확히 한 번 전송 => 중복 없는 전송이 이루어진다.

중복 없는 전송 => 정확히 한 번 전송됐다고 확신할 수 없다.

카프카에서 말하는 정확히 한 번 전송이란, 프로듀서와 브로커 사이의 ACK을 받지 못한 상황에서의 정확히 한 번 전송을 의미한다.

카프카에서는 트랜잭션과 같은 전체적인 프로세스 처리를 의미한다. => 트랜잭션 API를 이용하여 구현함.

- 프로듀서
- 트랜잭션 코디네이터
- 브로커
- 트랜잭션 토픽
- 컨트롤 메시지

카프카에서 트랜잭션은 트랜잭션 코디네이터에 의해 관리된다. 트랜잭션 코디네이터는 브로커들 중 하나가 역할을 맡는다. 그리고 트랜잭션 로그를 트랜잭션 토픽에 내용이 기록된다.

- transaction.state.log.num.partitions=50
- transatcion.state.log.replication.factor=3

1. FindCoorinatorRequest: 프로듀서가 브로커들에게 코디네이터를 찾는 요청을 한다. 그리고 요청한 PID와 TID를 연결한 정보를 매핑하는 역할을 해준다.
2. InitPidRequest: 프로듀서가 코디네이터에게 트랜잭션을 초기화 요청을 한다. 프로듀서에서 넘겨준 PID와 TID를 트랜잭션 토픽에 기록한다. 이때 에포크를 이용해 신뢰성을 보장한다.(서버가 다운되는 상황에서의 신뢰성 보장)
3. beginTransaction(): 프로듀서가 스스로에게 트랜잭션 시작을 기록한다. 아직 코디네이터와 통신을 한 것은 아니다.
4. 상태 추가: 프로듀서가 트랜잭션에 트랜잭션 시작을 알린다. TID와 파티션0의 정보가 트랜잭션 토픽에 기록된다. 기본 1분 동안 업데이트가 없으면 해당 트랜잭션은 실패된다.
5. 메시지 전송: 메시지 토픽이 있는 브로커에 메시지가 기록된다.
6. 트랜잭션 종료: 브로커에게 트랜잭션 종료 요청을 한다. commit 또는 abort가 있으며, 트랜잭션 토픽에 기록을 한다.
7. 메시지 토픽에 표시: 트랜잭션 코디네이터가 트랜잭션 토픽에 기록한 트랜잭셩 커밋 표시를 메시지 토픽에 기록한다. 컨트롤 메시지라고 불린다.(페이로드가 없음) 이로 인해 메시지 토픽에는 2개의 레코드가 존재하고 오프셋은 결과적으로 총 2개가 증가된다.
8. 트랜잭션 완료: 코디네이터가 트랜잭션 토픽에 comitted를 기록하고 프로듀서에게 알려준다.
