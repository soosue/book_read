# 6. 컨슈머의 내부 동작 원리와 구현

- 컨슈머 역할

![image](https://user-images.githubusercontent.com/54942017/182159047-a6174f26-3931-4520-b740-39c642020d24.png)

## 6.1 컨슈머 오프셋 관리

? 컨슈머가 재시작하거나 문제가 발생해 교체되었을 때 마지막으로 읽은 메시지 이후부터 읽기 위해 `위치를 기록` 하는데 `오프셋`이라 한다. => 다음으로 읽을 위치를 기록

=> 토픽에 저장한다.(`__consumer_offsets`) `컨슈머 그룹별`로 오프셋 정보가 기록됨.
=> 컨슈머 그룹, 토픽, 파티션에 대한 정보 등이 기록됨.

![image](https://user-images.githubusercontent.com/54942017/182162397-41f01c3d-d000-429b-b6a2-ed2d6f2cd93c.png)

```
브로커 설정파일 server.properties

- offsets.topic.num.partitions: 50      => 파티션이 많은 이유는 여러 컨슈머들이 붙어서 정보를 업데이트 할 수 있기 때문이다.
- offsets.topic.replication.factor: 3
```
## 6.2 그룹 코디네이터

? 운영을 하다보면 토픽의 파티션들이나 컨슈머 그룹의 컨슈머들에게 변화가 생길 수 있다. 이 때, 카프카는 컨슈머 리밸런싱을 통해 작업을 균등하게 분배하는데, 이 역할을 `그룹 코디네이터`가 한다.

- 그룹 코디네이터: 컨슈머 그룹의 토픽과 컨슈머들을 트래킹. => bootstrap.brokers의 브로커에게 초기 커넥션 요청시 생성됨.

- `컨슈머 그룹별 그룹 코디네이터`, `브로커 중 하나에 위치`

![image](https://user-images.githubusercontent.com/54942017/182185588-10e9527c-53c3-4eb0-807e-006deae82e9d.png)

---

### 컨슈머 그룹 등록 과정 with 그룹 코디네이터

1. bootstrap.brokers 리스트의 브로커에게 초기 커넥션 요청
2. 브로커는 그룹 코디네이터 생성 & 컨슈머에게 응답 / 코디네이터는 group.initial.rebalance.delay.ms 동안 대기
3. 컨슈머는 컨슈머 등록 요청을 함.(to 그룹 코디네이터). 가장 빨리 요청한 컨슈머 = 리더 컨슈머
4. 리더 컨슈머에 대한 등록 요청 응답으로 해당 그룹의 토픽 파티션 리스트 등을 보냄
5. 리더 컨슈머는 컨슈머 파티션 할당 전략에 따라 그룹내 컨슈머들에게 파티션 할당 후 그룹 코디네이터에게 정보 전달
6. 그룹 코디네이터는 해당 정보를 캐시하고, 컨슈머들에게 성공을 알림
7. 컨슈머들은 자신에게 할당된 파티션에서 메시지를 가져옴

---

### 컨슈머 등록(join), 탈퇴(leave), 장애(heartbeat)

장애시 처리는 heartbeat 체크를 통해서 이루어진다.
- heartbeat.interval.ms: 3000,
- session.timeout.ms: 10000,
- max.poll.interval.ms: 300000,

이 설정은 유지하는 것이 좋다.
- 빠르면 리밸런싱 자주
- 느리면 메시지 못 읽을 가능성

**주의. 리밸런싱은 비용이 매우 크다.**

---

## 6.3 스태틱 멤버십

----
### 스태틱 멤버십이 도입된 이유
컨슈머를 설정 변경이나 업데이트 등 특별한 이유로 인해서 재시작 해야하는 경우가 있을 수 있다.

재시작 해주면 되는데 문제는 그 때마다 리밸런싱이 일어난다는 것이다.

아마도 컨슈머가 컨슈머 그룹에서 떠날 때 1번, 다시 컨슈머 그룹에 합류할 때 1번. 적어도 2번 정도 일어날 수 있다.

이것은 낭비이므로, 이를 방지하기 위해 스태틱 멤버십이라는 개념이 2.3버전부터 도입됐다.

---
### 리밸런싱이 일어나는 배경과 스태틱 멤버십 적용 방법
리밸런싱이 일어나는 배경은 컨슈머 그룹은 컨슈머를 컨슈머ID를 통해서 컨슈머를 식별하는데, 이 값은 임시로 매겨진다.

그렇기 때문에 동일한 컨슈머가 재시작하는 경우에도 컨슈머ID가 다시 부여되므로, 새로운 컨슈머로 인식되어 리밸런싱이 일어난다.

스태틱 멤버십은 이 컨슈머ID 값을 고정하는 것이다.

기본값이 null string인 group.instance.id를 2.3에서 고유하게 설정해주는 것이 그 방법이다.

예를 들어 consumer-호스트네임이나, consumer-서버ip 처럼 입력할 수 있다.

---
### 스태틱 멤버십 동작과 주의점
스태틱 멤버십을 적용해주면 적용된 컨슈머는 컨슈머 그룹을 떠날 때, 그룹 코디네이터에게 알리지 않기 때문에 리밸런싱이 일어나지 않고, 다시 합류할 때도 기존 구성원이므로 리밸런싱이 일어나지 않아서 총 2번의 리밸런싱을 피할 수 있다.

다만 주의할 점이 하나 있다. session.timeout.ms를 기본값보다 크게 설정해야 한다. 코디네이터에게 나갈 때 알리지는 않더라도, 하트비트를 받지 못하면 리밸런싱이 일어나기 때문이다.

따라서 컨슈머 재시작 시간을 고려해서 2분이라면 2분보다 크게 설정해야 불필요한 리밸런싱을 방지할 수 있다.

---