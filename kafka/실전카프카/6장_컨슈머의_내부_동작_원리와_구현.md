# 6. 컨슈머의 내부 동작 원리와 구현

- 컨슈머 역할

![image](https://user-images.githubusercontent.com/54942017/182159047-a6174f26-3931-4520-b740-39c642020d24.png)

## 6.1 컨슈머 오프셋 관리

? 컨슈머가 재시작하거나 문제가 발생해 교체되었을 때 마지막으로 읽은 메시지 이후부터 읽기 위해 `위치를 기록` 하는데 `오프셋`이라 한다. => 다음으로 읽을 위치를 기록

=> 토픽에 저장한다.(`__consumer_offsets`) `컨슈머 그룹별`로 오프셋 정보가 기록됨.
=> 컨슈머 그룹, 토픽, 파티션에 대한 정보 등이 기록됨.

![image](https://user-images.githubusercontent.com/54942017/182162397-41f01c3d-d000-429b-b6a2-ed2d6f2cd93c.png)

```
브로커 설정파일 server.properties

- offsets.topic.num.partitions: 50      => 파티션이 많은 이유는 여러 컨슈머들이 붙어서 정보를 업데이트 할 수 있기 때문이다.
- offsets.topic.replication.factor: 3
```
## 6.2 그룹 코디네이터

? 운영을 하다보면 토픽의 파티션들이나 컨슈머 그룹의 컨슈머들에게 변화가 생길 수 있다. 이 때, 카프카는 컨슈머 리밸런싱을 통해 작업을 균등하게 분배하는데, 이 역할을 `그룹 코디네이터`가 한다.

- 그룹 코디네이터: 컨슈머 그룹의 토픽과 컨슈머들을 트래킹. => bootstrap.brokers의 브로커에게 초기 커넥션 요청시 생성됨.

- `컨슈머 그룹별 그룹 코디네이터`, `브로커 중 하나에 위치`

![image](https://user-images.githubusercontent.com/54942017/182185588-10e9527c-53c3-4eb0-807e-006deae82e9d.png)

---

### 컨슈머 그룹 등록 과정 with 그룹 코디네이터

1. bootstrap.brokers 리스트의 브로커에게 초기 커넥션 요청
2. 브로커는 그룹 코디네이터 생성 & 컨슈머에게 응답 / 코디네이터는 group.initial.rebalance.delay.ms 동안 대기
3. 컨슈머는 컨슈머 등록 요청을 함.(to 그룹 코디네이터). 가장 빨리 요청한 컨슈머 = 리더 컨슈머
4. 리더 컨슈머에 대한 등록 요청 응답으로 해당 그룹의 토픽 파티션 리스트 등을 보냄
5. 리더 컨슈머는 컨슈머 파티션 할당 전략에 따라 그룹내 컨슈머들에게 파티션 할당 후 그룹 코디네이터에게 정보 전달
6. 그룹 코디네이터는 해당 정보를 캐시하고, 컨슈머들에게 성공을 알림
7. 컨슈머들은 자신에게 할당된 파티션에서 메시지를 가져옴

---

### 컨슈머 등록(join), 탈퇴(leave), 장애(heartbeat)

장애시 처리는 heartbeat 체크를 통해서 이루어진다.
- heartbeat.interval.ms: 3000,
- session.timeout.ms: 10000,
- max.poll.interval.ms: 300000,

이 설정은 유지하는 것이 좋다.
- 빠르면 리밸런싱 자주
- 느리면 메시지 못 읽을 가능성

**주의. 리밸런싱은 비용이 매우 크다.**

---

## 6.3 스태틱 멤버십

----
### 스태틱 멤버십이 도입된 이유
컨슈머를 설정 변경이나 업데이트 등 특별한 이유로 인해서 재시작 해야하는 경우가 있을 수 있다.

재시작 해주면 되는데 문제는 그 때마다 리밸런싱이 일어난다는 것이다.

아마도 컨슈머가 컨슈머 그룹에서 떠날 때 1번, 다시 컨슈머 그룹에 합류할 때 1번. 적어도 2번 정도 일어날 수 있다.

이것은 낭비이므로, 이를 방지하기 위해 스태틱 멤버십이라는 개념이 2.3버전부터 도입됐다.

---
### 리밸런싱이 일어나는 배경과 스태틱 멤버십 적용 방법
리밸런싱이 일어나는 배경은 컨슈머 그룹은 컨슈머를 컨슈머ID를 통해서 컨슈머를 식별하는데, 이 값은 임시로 매겨진다.

그렇기 때문에 동일한 컨슈머가 재시작하는 경우에도 컨슈머ID가 다시 부여되므로, 새로운 컨슈머로 인식되어 리밸런싱이 일어난다.

스태틱 멤버십은 이 컨슈머ID 값을 고정하는 것이다.

기본값이 null string인 group.instance.id를 2.3에서 고유하게 설정해주는 것이 그 방법이다.

예를 들어 consumer-호스트네임이나, consumer-서버ip 처럼 입력할 수 있다.

---
### 스태틱 멤버십 동작과 주의점
스태틱 멤버십을 적용해주면 적용된 컨슈머는 컨슈머 그룹을 떠날 때, 그룹 코디네이터에게 알리지 않기 때문에 리밸런싱이 일어나지 않고, 다시 합류할 때도 기존 구성원이므로 리밸런싱이 일어나지 않아서 총 2번의 리밸런싱을 피할 수 있다.

다만 주의할 점이 하나 있다. session.timeout.ms를 기본값보다 크게 설정해야 한다. 코디네이터에게 나갈 때 알리지는 않더라도, 하트비트를 받지 못하면 리밸런싱이 일어나기 때문이다.

따라서 컨슈머 재시작 시간을 고려해서 2분이라면 2분보다 크게 설정해야 불필요한 리밸런싱을 방지할 수 있다.

---

## 6.4 컨슈머 파티션 할당 전략

프로듀서의 파티셔너는 레코드를 토픽의 어느 파티션으로 전송할지를 결정하는 역할을 한다.

__컨슈머도 대상 토픽의 어느 파티션으로부터 레코드를 읽어올지 결정한다.__

컨슈머 그룹의 리더 컨슈머가 정해진 파티션 할당 전략에 따라 각 컨슈머와 대상 토픽의 파티션을 매칭시키는데,

파티션 할당 전략은 컨슈머 옵션의 partition.assignment.strategy 로 표시하며 총 네가지를 제공한다.

- RangeAssignor(레인지 전략) : 파티션 할당의 기본값. 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용
- RoundRobinAssignor(라운드 로빈 전략) : 사용 가능한 파티션과 컨슈머들을 라운드 로빈으로 할당. 균등한 분배 가능
- StickyAssignor(스티키 전략) : 컨슈머가 컨슘하고 있는 파티션을 계속 유지할 수 있음
- CooperativeStickyAssignor(협력적 스티키 전략) : 스티키와 유사하지만, 전체 일시 정지가 아닌 연속적인 재조정 방식

## 6.4.1 레인지 파티션 할당 전략

구독하는 토픽에 대한 파티션을 순서대로 나열한 후, 컨슈머를 순서대로 정렬하고, 전체 파티션 수/컨슈머 수 개수대로 균등하게 할당한다.

균등하게 나눠지지 않는 경우에는 앞쪽의 컨슈머들은 추가 파티션을 할당받게 된다. 이러면 앞쪽의 컨슈머들이 많은 파티션들을 소비하게 된다.

불균형하게 할당되지만 특수한 경우엔 도움이 된다. 토픽 2개가 같은 파티션 개수를 가지고 있을 때, 프로듀서가 2개의 토픽에 같은 레코드 키를 이용하여 메시지를 전송할 때, 레인지 파티션 할당 전략이면 하나의 컨슈머가 두 토픽의 동일한 파티션을 컨슘하게 된다.

## 6.4.2 라운드 로빈 파티션 할당 전략

모든 토픽의 모든 파티션을 일렬로 나열하고, 컨슈머 그룹내 컨슈머들도 모두 나열한 후, 하나씩 번갈아가면서 할당하는 전략이다.

조금 더 균등하게 배분할 수 있다.

## 6.4.3 스티키 파티션 할당 전략

리밸런싱이 일어난다면 컨슈머 그룹의 컨슈머들이 기존에 매핑되었던 파티션과 다시 매핑된다고 보장할 수 없다. 이런 재할당을 최대한 유지하려고 하는 것이 스티키 파티션 할당 전략이다.

첫번째로는 균형 잡힌 파티션을 할당하려고 하고, 두번째로 기존 할당된 파티션 정보를 보장한다.

```
규칙

컨슈머들의 파티션 수 차이는 1
기존 파티션 할당은 최대한 유지
재할당 동작 시 유효하지 않은 파티션 할당은 제거
할당되지 않은 파티션들을 균형 맞추는 방법으로 컨슈머들에 할당
```

## 6.4.4 협력적 스티키 파티션 할당 전략

스티키 파티션 할당 전략에서 컨슈머 그룹내 리밸런싱 동작이 한층 더 고도화됐다.

컨슈머 그룹 내에서 리밸런싱이 일어날 때 다운타임이 일어나는 것을 더욱 줄여준다.

컨슈머 리밸런싱 동작에서 지금까지는 내부적으로 EAGER라는 리밸런스 프로토콜을 사용했고, 이는 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소했다.

그렇게 하는 이유는 컨슈머들의 파티션 소유권 변경 때문이다. 파티션 0을 컨슈머 A가 가지고 있는데, 컨슈머 B에게 주어야 한다고 할 때, 파티션 0을 한 컨슈머 그룹내에서 2개의 컨슈머가 소유하게 할 수 없으므로 반드시 취소를 해야 넘겨줄 수 있다. 그리고 모두 취소하면 로직이 더 단순하게 구현될 수 있다.

하지만 리밸런싱에서 모든 파티션 할당을 취소하는 동작은 리소스를 많이 사용하는 컨슈머 그룹에서는 큰 문제가 된다. 다운타임 때문이다.

리밸런싱을 감지, 중지, 재시작이라고 나눠 놓으면 리밸런싱 하는 동안에도 토픽에 메시지는 계속 쌓이기 때문에, LAG은 급격하게 증가된다.

이를 위해 2.3에는 카프카 커넥트에, 2.4부터 컨슈머 클라이언트에도 적용이 됐다. 협력적 스티키는 내부적으로 COOPERATIVE 프로토콜을 적용했고, 이 프로토콜은 리밸런싱 동작하기 전의 컨슈머 상태를 유지할 수 있게 됐다.

기존 스티키는 한 번의 리밸런싱으로 모든 작업을 완료했다면, 협력적 스티키는 여러번의 리밸런싱을 통해 작업을 완료한다.
```
1. 먼저, 할당을 취소해야할 파티션 정보를 취합하여, 할당을 취소하고 (첫번째 리밸런싱)
2. 취소된 파티션들을 재할당한다.(두번째 리밸런싱)

이렇게 되면 할당 취소 되지 않은 파티션들은 다운타임 없이 가져갈 수 있다.
```

## 6.5 정확히 한 번 컨슈머 동작

프로듀서의 `정확히 한 번 전송` 동작을 위해서 브로커 측에는 전체 트랜잭션을 관리하면서 프로듀서의 동작을 보조하는 트랜잭션 코디네이터가 필요했다.

트랜잭션 코디네이터는 프로듀서의 정확히 한 번 전송이 성공하면 해당 레코드의 트랜잭션 성공을 표시하는 특수한 메시지를 추가했다. (메시지가 하나 더 쌓임)

따라서 이 특수한 메시지를 표시한 레코드만 읽는 것이 `정확히 한 번 읽는 동작`이 된다.


트랜잭션 컨슈머는 ISOLATION_LEVEL_CONFIG를 read_committed로 설정하면 된다. (기본값은 read_uncommitted)

트랜잭션 코디네이터와 통신하는 부분은 없이, 트랜잭션이 완료된 메시지만 읽는다.

명심해야할 점은, 컨슈머에서 정확히 한 번이라는 의미는 `트랜잭션 처리된 메시지를 읽는다`는 의미이다.

카프카 컨슈머 어플리케이션에서 정확히 한 번을 지원하는 경우도 있으니 잘 찾아서 원하는 기능이 맞는지, 구현 가능한지 여부를 꼭 확인하고 적용하도록 한다.

## 6.6 정리

메시지를 가져올 때, 지연이 발생하지 않아야 하며, 손실되는 메시지도 없어야 하고, 최대한 중복도 없어야 한다.

이를 위해 리밸런싱 전략과 트랜잭션 동작이 존재하니 잘 아록 사용하도록 하자.