#### 책을 읽으면서 놓치고 있었거나 새롭거나 다르게 보인 점들을 메모.

1. HTTP는 애플리케이션 단에서의 프로토콜이므로, 실제 목적지인 IP에 대한 정보가 필요없이 리퀘스트의 헤더, 바디, 리스폰스의 헤더, 바디 정보만 있으면 되고 IP나 PORT 같은 정보는 전송 관련 일을 하는 TCP나 네트워크 단인 IP 단에서 필요한 정보이다.
2. 브라우저나 애플리케이션에서 HTTP 요청을 보내게 되면, 브라우저와 애플리케이션 자체가 HTTP 요청을 직접 보내는 것이 아니라 OS에 내장된 네트워크 제어용 소프트웨어(프로토콜 스택)에 의뢰하여 HTTP 요청을 보낸다. 즉, 네트워크는 브라우저나 애플리케이션이 직접하는 것이 아니라 OS에 의뢰하여 네트워크를 제어한다.
3. http: 뿐만 아니라 file: ftp: mailto: 도 URL이다.
4. GET과 POST의 차이 중 GET은 리퀘스트의 크기에 제한이 있다. 생각해보면 무언가를 응답받기 위한 리퀘스트에 어마어마한 양의 데이터가 필요하진 않을 것이다.

p119
1. '소켓을 연결한다', '커넥션을 맺는다', '세션을 맺는다'는 실제로 무언가 연결이 되어 있진 않다. 그저 양측의 소켓에 송신, 수신측의 정보를 기록해놓고 해당 정보를 바탕으로 통신할 때 사용하는 것 뿐이다.
2. 연결을 끊는다는 것은 통신할 때 사용하는 소켓에 적힌 제어 정보를 지우거나 사용하지 않겠다고 기록하는 것이지 않을까?

p118
1. 수신측(서버)으로부터 SYN을 받아야 소켓에 수신측의 IP주소나 포트 번호 등의 정보를 기록한다.

p120
1. 프로토콜 스택은 애플리케이션으로부터 데이터를 받아서 송신하는데, 받은 데이터를 저장하는 버퍼가 있다. 애플리케이션이 프로토콜 스택에 데이터를 전달할 때 데이터의 크기를 크게 또는 매우 잘게 나눠 보낼 수 있는데, 그대로 보내게 되면 네트워크 이용 효율이 떨어지기 때문에 받은 데이터를 버퍼에 저장해놓고, MSS(Maximum Segment Size)에 가깝게 쌓일 때까지 모았다가 패킷을 만들어 보내거나, 타이머를 두어 일정 시간이 지나면 보내게 하여 네트워크 이용 효율을 높인다. 물론 애플리케이션에서 데이터를 전달하는대로 패킷을 보내도록 설정할 수도 있다.
2. MTU(Maximum Transmission Unit) = IP헤더 길이 + TCP헤더 길이 + MSS(데이터 길이) = 이더넷에서 1,500바이트 = 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이.
3. MSS = 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP데이터의 최대 길이

p128
1. TCP는 송신한 패킷을 수신측에서 ACK이 올 때까지 송신용 버퍼 메모리 영역에 보관해둔다. 오지 않으면 다시 패킷을 보낸다.
2. 단 도중에 어떤 문제던간에 데이터가 도착하지 않는 경우, 몇 번 더 보내봐도 ACK이 없다면 송신 동작을 강제로 종료한다.(RST, reset)

p130
1. ACK을 대기하는 시간은 그 전 ACK들을 기반으로 동적으로 설정한다.

p131
1. 패킷을 하나 보내고 ACK을 받고, 하나 보내고 ACK을 받고를 반복하면 효율이 너무 떨어진다. 그러므로 여러 개의 패킷을 보내는데 이를 '윈도우 제어'라고 한다.
2. 수신측의 능력을 초과해서 패킷을 보내는 일을 방지하기 위해 수신측 버퍼 메모리의 빈 부분만큼을 ACK의 TCP헤더의 Window 필드에 담아 보내며 제어한다.

p134
1. TCP 수신측은 ACK번호나 Window를 보낼 때, 바로 보내지 않고 잠시 기다렸다가 보내는데, 그 사이에 다른 ACK번호나 Window를 보내야한다면, 기존 패킷에 같이 담아서 보낸다.(제일 최신 정보만 담아서 패킷을 보낸다)

p137
1. 처음 수신된 패킷은 커널의 임시 버퍼에 저장된다. NIC에서 받은 데이터들이 저장되며, 검증을 거친 후 TCP 수신 버퍼로 이동한다.

