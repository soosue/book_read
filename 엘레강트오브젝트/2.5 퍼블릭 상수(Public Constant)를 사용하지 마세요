public static final을 사용하지 마세요.

문자열의 마지막에 \r\n을 붙여야하는 기능이 필요하다고 가정해보자.
A클래스에서 "\r\n"을 사용하고 있고,
B클래스에서도 "\r\n"을 사용하고 있다.

이 둘의 코드 중복을 줄이기 위해서 어떻게 해야할까?

class Constants {
    public static final String EOL = "\r\n";
}
위와 같이 정의하고 A클래스와 B클래스에서 Constants.EOL을 사용하면 된다.
잘 해결된 것일까? 아니다!

중복은 해결했지만,
결합도가 높아졌고,
응집도가 낮아졌다.

1. 결합도가 높아짐
Constants.EOL가 수정되면, 영향을 받게 된다.
당연한 말이지만 문제는, EOL이 사용되는 곳을 예측할 수 없고, EOL이 사용되어야하는 방식을 퍼블릭 상수로는 가이드 할 수가 없다는 점이다.
따라서 어느 곳에서나 생각없이 쉽게 사용하게 되고, 변경이 일어나야하는 경우에, 쉽게 변경하지 못하게 된다.

2. 응집도가 낮아졌다.
응집도란 객체 스스로 자신의 일과 관련된 기능을 할 수 있는가이다.
여기서 응집도가 낮아진 것은 Constants에 해당하는 말이다.

Constants는 자신이 어떤 일을 해야하는지 알 수 없고,
객체로서의 존재 이유도 없으며, 단순히 텍스트 덩어리가 되어버린다.

3. 그렇다면 어떻게?
EOL의 사용처를 가이드할 수 있으면서, 객체로서의 의미가 있도록 만든다.
즉 새로운 클래스를 만들도록 한다.

class EOLString {
    private final String origin;
    EOLString(String src) {
        this.origin = src;
    }
    @Override
    String toString() {
        return String.format("%s\r\n", origin);
    }
}
이렇게 되면, 우리가 처음에 필요했던 문자열의 마지막에 \r\n을 붙여야하는 기능을 EOLString이 책임지게 된다.
우리는 EOLString이 문자열 마지막에 \r\n을 붙여준다는 사실을 알게 돼서, 필요한 곳에서만 사용할 수 있게 되고
따라서 아무 곳에서나 EOLString을 사용하지 않게 되므로 결합도가 줄어들고,
EOLString의 책임이 존재하므로 객체의 존재이유가 생겨서 응집도 또한 높아진다.

핵심)
public static final을 쓰지마라.
아무 곳에서나 쓰게 되어 결합도가 커지며,
해당 클래스는 아무 의미가 없어 응집도가 낮아진다.
책임을 맡은 새로운 클래스를 만들어라.
