모든 클래스를 상태 변경이 불가능한 불변 클래스(immutable class)로 만들면 유지보수성을 크게 향상시킬 수 있다.

이유를 살펴보자.

1. 객체지향적으로 봤을 때, 가변 객체는 작은 모순이 있다.
Cash five = new Cash(5);
five.mul(10);
System.out.println(five); // 50이 나온다.

여기서 five 대신 cash나 money와 같은 변수명으로 변경할 수 있겠지만, 이와 같이 간단한 경우에 해당한다.

불변 객체일 경우는 상태를 변경할 수 없어, 새로운 객체를 만들어야 한다.
Cash five = new Cash(5);
Cash fifty = five.mul(10);
System.out.println(fifty);

2. 식별자 가변성
Hash를 사용하는 클래스에서 식별자로 사용될 경우에, 가변 객체가 식별자로 사용되고 변경이 일어나면, 결과를 예측할 수 없게 된다.

3. 실패 원자성
실패 원자성이란 객체가 완전한 상태거나 아니면 실패한 상태거나 둘 중 하나라는 특성이다.
불변 객체라면, new로 생성 당시에 이미 완전한 상태가 되어서 이후 요청에 대해 걱정할 필요가 없어진다.

가변 객체라면 상태 확인 작업이 이루어져야 한다.
public void mul(int factor) {
    int before = this.dollars;
    this.dollars = *= factor;
    if (/* cents와 관련해서 뭔가 잘못됨 */) {
        this.dollars = before;
        throw new RuntimeException("에러");
    }
    this.cents *= factor;
}

불변 객체라면 이런 고민이 필요없어진다.

4. 시간적 결합(Temporal Coupling)
시간적 결합이란 객체가 시간에 따라서 초기화가 이루어지는 것이며, 가변 객체에서만 일어난다.
10번 줄에서는 아직 객체가 완전하지 않은데, 15번 줄에서는 객체가 완전해졌을 수 있다.
13번 줄에서 완전하지 않은 상태에서 특정 요청을 한다면 에러가 발생할 수 있다.

이런 프로그래밍의 순서를 기억해야한다면, 유지보수가 쉽지 않아진다.
불변 객체는 인스턴스화와 초기화를 분리시킬 수 없으므로 항상 완전하다.

5. 부수효과(Side effect-free) 제거
객체가 코드 중간에 변경될 것을 걱정할 필요가 없어진다.
이점은 유지보수에서 염두에 두고 있어야 할 한 부분이 사라진다는 것이고, 정말 큰 장점이다.

6. NULL 참조 없애기
null은 안 좋다. 그 이유는 다음에 볼 것이다.
불변 객체를 사용하게 되면, new로 생성시 초기화가 되어야하므로 null인 상태를 가질 수 없게 된다.

7. 스레드 안정성
여러 스레드에서 불변 객체를 동시에 접근하더라도 변하지 않기 때문에 안전하다.

8. 더 작고 더 단순한 객체
불변 객체를 크게 만드는 일은 어렵다.
생성자로 10개가 넘는 인자를 받도록 만들고 싶지는 않을 것이다.
자연스럽게 더 작게 만들게 되고, 이는 유지보수성을 더 높여주게 된다.

핵심)
final을 이용하여 불변 객체로 만들어줘라.
더 작고 유지보수성이 높게 클래스를 만들게 되고,
여러 장점들을 얻게 될 것이다.